<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stack Visualization (Push / Pop)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 20px;
    }
    h1 {
      margin-top: 0;
    }
    #layout {
      display: flex;
      gap: 24px;
      max-width: 900px;
    }
    #left-panel, #right-panel {
      flex: 1;
    }
    textarea {
      width: 100%;
      height: 160px;
      font-family: monospace;
      resize: vertical;
    }
    #stack-container {
      border: 2px solid #333;
      border-radius: 8px;
      width: 160px;
      min-height: 220px;
      padding: 10px;
      display: flex;
      flex-direction: column-reverse; /* bottom = top of stack visually */
      justify-content: flex-start;
      gap: 6px;
      box-sizing: border-box;
      background: #fafafa;
    }
    .stack-item {
      height: 32px;
      border-radius: 6px;
      border: 2px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      box-sizing: border-box;
      transition: transform 0.2s;
      background: white;
    }
    .stack-item.top {
      outline: 3px solid orange;
      transform: translateY(-3px);
    }
    .stack-item.changed {
      background: #ffe1e1;
    }
    #controls button {
      margin-right: 8px;
      margin-top: 4px;
      padding: 6px 12px;
    }
    #description {
      margin-top: 8px;
      font-style: italic;
      min-height: 24px;
    }
    #step-indicator {
      margin-top: 4px;
      font-size: 0.9rem;
      color: #555;
    }
    #stack-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <h1>Stack Visualization (Push / Pop)</h1>

  <div id="layout">
    <div id="left-panel">
      <h3>Operations</h3>
      <p>Write one operation per line, e.g.:</p>
      <pre style="background:#f4f4f4;padding:8px;border-radius:4px;">
push 10
push 20
push 30
pop
push 5</pre>
      <textarea id="ops-input"></textarea><br />
      <button id="generate-btn">Generate Steps</button>
    </div>

    <div id="right-panel">
      <h3>Stack</h3>
      <div id="stack-labels">
        <span>Bottom</span>
        <span>Top</span>
      </div>
      <div id="stack-container"></div>

      <div id="controls">
        <button id="prev-btn">◀ Prev</button>
        <button id="play-btn">▶ Play</button>
        <button id="pause-btn">⏸ Pause</button>
        <button id="next-btn">Next ▶</button>
        <button id="reset-btn">⟲ Reset</button>
        <label style="margin-left: 8px;">
          Speed (ms):
          <input id="speed-input" type="number" value="600" min="50" style="width: 70px;" />
        </label>
      </div>

      <div id="description"></div>
      <div id="step-indicator"></div>
    </div>
  </div>

  <script>
    // 1. Parse operations from textarea
    function parseOperations(text) {
      const lines = text.split(/\r?\n/);
      const ops = [];

      for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        const lower = line.toLowerCase();
        if (lower.startsWith("push")) {
          const parts = line.split(/\s+/);
          if (parts.length < 2) continue;
          const value = Number(parts[1]);
          if (Number.isNaN(value)) continue;
          ops.push({ type: "push", value });
        } else if (lower === "pop") {
          ops.push({ type: "pop" });
        } else {
          // ignore unknown commands
        }
      }
      return ops;
    }

    // 2. Simulate stack with states recording
    // State shape:
    // {
    //   stack: [...],
    //   op: "push" | "pop" | null,
    //   value: number | null,
    //   topIndex: number | null,
    //   changedIndex: number | null,
    //   description: string
    // }
    function buildStackStates(ops) {
      const stack = [];
      const states = [];

      function record(op, value, topIndex, changedIndex, desc) {
        states.push({
          stack: stack.slice(),
          op,
          value,
          topIndex,
          changedIndex,
          description: desc
        });
      }

      // initial state
      record(null, null, stack.length ? stack.length - 1 : null, null, "Initial empty stack");

      for (const step of ops) {
        if (step.type === "push") {
          record("push", step.value, stack.length ? stack.length - 1 : null, null,
            `About to push ${step.value} onto the stack`);
          stack.push(step.value);
          record("push", step.value, stack.length - 1, stack.length - 1,
            `Pushed ${step.value}. New top is ${step.value}`);
        } else if (step.type === "pop") {
          if (stack.length === 0) {
            record("pop", null, null, null, "Tried to pop, but the stack is empty");
          } else {
            record("pop", null, stack.length - 1, stack.length - 1,
              `About to pop the top element ${stack[stack.length - 1]}`);
            const removed = stack.pop();
            record("pop", removed, stack.length ? stack.length - 1 : null, null,
              `Popped ${removed} from the stack`);
          }
        }
      }

      record(null, null, stack.length ? stack.length - 1 : null, null, "Finished all operations");
      return states;
    }

    // 3. Rendering one state
    const stackContainer = document.getElementById("stack-container");
    const descriptionEl = document.getElementById("description");
    const stepIndicatorEl = document.getElementById("step-indicator");

    function renderState(state, index, total) {
      stackContainer.innerHTML = "";

      // We display stack bottom at the bottom of the box,
      // because of flex-direction: column-reverse.
      // So index 0 in the data is visually at the bottom.
      state.stack.forEach((value, idx) => {
        const div = document.createElement("div");
        div.className = "stack-item";
        div.textContent = value;

        if (idx === state.topIndex) {
          div.classList.add("top");
        }
        if (idx === state.changedIndex) {
          div.classList.add("changed");
        }

        stackContainer.appendChild(div);
      });

      descriptionEl.textContent = state.description || "";
      stepIndicatorEl.textContent = `Step ${index + 1} / ${total}`;
    }

    // 4. Player logic (same pattern as before)
    let states = [];
    let currentIndex = 0;
    let timer = null;

    function stopTimer() {
      if (timer !== null) {
        clearInterval(timer);
        timer = null;
      }
    }

    function showCurrent() {
      if (states.length === 0) return;
      currentIndex = Math.max(0, Math.min(currentIndex, states.length - 1));
      renderState(states[currentIndex], currentIndex, states.length);
    }

    function play() {
      if (states.length === 0) return;
      if (timer !== null) return;

      const speed = parseInt(document.getElementById("speed-input").value, 10) || 600;

      timer = setInterval(() => {
        currentIndex++;
        if (currentIndex >= states.length) {
          currentIndex = states.length - 1;
          stopTimer();
        }
        showCurrent();
      }, speed);
    }

    function pause() {
      stopTimer();
    }

    function next() {
      if (states.length === 0) return;
      currentIndex = Math.min(currentIndex + 1, states.length - 1);
      showCurrent();
    }

    function prev() {
      if (states.length === 0) return;
      currentIndex = Math.max(currentIndex - 1, 0);
      showCurrent();
    }

    function reset() {
      currentIndex = 0;
      showCurrent();
    }

    // 5. Hook up UI
    document.getElementById("play-btn").addEventListener("click", play);
    document.getElementById("pause-btn").addEventListener("click", pause);
    document.getElementById("next-btn").addEventListener("click", next);
    document.getElementById("prev-btn").addEventListener("click", prev);
    document.getElementById("reset-btn").addEventListener("click", reset);

    document.getElementById("generate-btn").addEventListener("click", () => {
      stopTimer();
      const text = document.getElementById("ops-input").value;
      const ops = parseOperations(text);
      states = buildStackStates(ops);
      currentIndex = 0;
      showCurrent();
    });

    // 6. Initialize with a default script of operations
    (function init() {
      const defaultOps = [
        "push 10",
        "push 20",
        "push 30",
        "pop",
        "push 5"
      ].join("\n");
      document.getElementById("ops-input").value = defaultOps;

      const ops = parseOperations(defaultOps);
      states = buildStackStates(ops);
      currentIndex = 0;
      showCurrent();
    })();
  </script>
</body>
</html>
